<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>spline_volume &mdash; PyHexSpline 0.2.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/documentation_options.js?v=938c9ccc"></script>
        <script src="../_static/doctools.js?v=9a2dae69"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            PyHexSpline
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hr_pqct_meshing.html">HR-pQCT Structured Hexahedral Meshing</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">PyHexSpline</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Module code</a></li>
      <li class="breadcrumb-item active">spline_volume</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for spline_volume</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">gmsh</span>
<span class="kn">import</span> <span class="nn">imutils</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>

<span class="c1"># matplotlib.use(&quot;TkAgg&quot;)</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">plotly.express</span> <span class="k">as</span> <span class="nn">px</span>
<span class="kn">import</span> <span class="nn">plotly.graph_objects</span> <span class="k">as</span> <span class="nn">go</span>
<span class="kn">import</span> <span class="nn">scipy.spatial</span> <span class="k">as</span> <span class="nn">ss</span>
<span class="kn">import</span> <span class="nn">shapely.geometry</span> <span class="k">as</span> <span class="nn">shpg</span>
<span class="kn">import</span> <span class="nn">SimpleITK</span> <span class="k">as</span> <span class="nn">sitk</span>
<span class="kn">from</span> <span class="nn">matplotlib.widgets</span> <span class="kn">import</span> <span class="n">Slider</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="kn">import</span> <span class="n">make_axes_locatable</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">ndarray</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">spatial</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">UnivariateSpline</span><span class="p">,</span> <span class="n">splev</span><span class="p">,</span> <span class="n">splprep</span><span class="p">,</span> <span class="n">splrep</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>
<span class="kn">from</span> <span class="nn">shapely</span> <span class="kn">import</span> <span class="n">Polygon</span>
<span class="kn">from</span> <span class="nn">SimpleITK.SimpleITK</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">find_contours</span>

<span class="n">LOGGING_NAME</span> <span class="o">=</span> <span class="s2">&quot;MESHING&quot;</span>
<span class="c1"># flake8: noqa: E203</span>


<div class="viewcode-block" id="OCC_volume">
<a class="viewcode-back" href="../spline_volume.html#spline_volume.OCC_volume">[docs]</a>
<span class="k">class</span> <span class="nc">OCC_volume</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sitk_image</span><span class="p">:</span> <span class="n">Image</span><span class="p">,</span>
        <span class="n">img_path</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">filepath</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">ASPECT</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">SLICE</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">UNDERSAMPLING</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">SLICING_COEFFICIENT</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">INSIDE_VAL</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">OUTSIDE_VAL</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">LOWER_THRESH</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">UPPER_THRESH</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">S</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">INTERP_POINTS</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">DP_SIMPLIFICATION_OUTER</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">DP_SIMPLIFICATION_INNER</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">debug_orientation</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">show_plots</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">thickness_tol</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">phases</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Class that imports a voxel-based model and converts it to a geometrical simplified representation</span>
<span class="sd">        through the use of splines for each slice in the transverse plane.</span>
<span class="sd">        Following spline reconstruction, the model is meshed with GMSH.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">LOGGING_NAME</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sitk_image</span> <span class="o">=</span> <span class="n">sitk_image</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">img_path</span> <span class="o">=</span> <span class="n">img_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filepath</span> <span class="o">=</span> <span class="n">filepath</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug_orientation</span> <span class="o">=</span> <span class="n">debug_orientation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">show_plots</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">show_plots</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ASPECT</span> <span class="o">=</span> <span class="n">ASPECT</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SLICE</span> <span class="o">=</span> <span class="n">SLICE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">THRESHOLD_PARAM</span> <span class="o">=</span> <span class="p">[</span><span class="n">INSIDE_VAL</span><span class="p">,</span> <span class="n">OUTSIDE_VAL</span><span class="p">,</span> <span class="n">LOWER_THRESH</span><span class="p">,</span> <span class="n">UPPER_THRESH</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">UNDERSAMPLING</span> <span class="o">=</span> <span class="n">UNDERSAMPLING</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SLICING_COEFFICIENT</span> <span class="o">=</span> <span class="n">SLICING_COEFFICIENT</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">S</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">=</span> <span class="n">K</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">INTERP_POINTS_S</span> <span class="o">=</span> <span class="n">INTERP_POINTS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dp_simplification_outer</span> <span class="o">=</span> <span class="n">DP_SIMPLIFICATION_OUTER</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dp_simplification_inner</span> <span class="o">=</span> <span class="n">DP_SIMPLIFICATION_INNER</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spacing</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coordsX</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coordsY</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xy_sorted_closed</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_mahalanobis</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_mahalanobis</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xnew</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ynew</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slice_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">([])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cortex_outer_tags</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cortex_inner_tags</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">MIN_THICKNESS</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">thickness_tol</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phases</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">phases</span><span class="p">)</span>

        <span class="c1"># Figure layout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">layout</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span>
            <span class="n">plot_bgcolor</span><span class="o">=</span><span class="s2">&quot;#FFF&quot;</span><span class="p">,</span>  <span class="c1"># Sets background color to white</span>
            <span class="n">xaxis</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Medial - Lateral position (mm)&quot;</span><span class="p">,</span>
                <span class="n">linecolor</span><span class="o">=</span><span class="s2">&quot;#BCCCDC&quot;</span><span class="p">,</span>  <span class="c1"># Sets color of X-axis line</span>
                <span class="n">showgrid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="c1"># Removes X-axis grid lines</span>
            <span class="p">),</span>
            <span class="n">yaxis</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Palmar - Dorsal position (mm)&quot;</span><span class="p">,</span>
                <span class="n">linecolor</span><span class="o">=</span><span class="s2">&quot;#BCCCDC&quot;</span><span class="p">,</span>  <span class="c1"># Sets color of Y-axis line</span>
                <span class="n">showgrid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="c1"># Removes Y-axis grid lines</span>
            <span class="p">),</span>
        <span class="p">)</span>

<div class="viewcode-block" id="OCC_volume.plot_mhd_slice">
<a class="viewcode-back" href="../spline_volume.html#spline_volume.OCC_volume.plot_mhd_slice">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_mhd_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot a slice of the SimpleITK.image.</span>

<span class="sd">        This helper function plots a specified slice of the SimpleITK.image file using Matplotlib.</span>
<span class="sd">        It also provides an interactive slider to navigate through different slices.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (SimpleITK.Image): The image to be plotted.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">img_view</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetArrayViewFromImage</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span>
            <span class="n">figsize</span><span class="o">=</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">img_view</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ASPECT</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">img_view</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ASPECT</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span>

        <span class="n">l</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span>
            <span class="n">img_view</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SLICE</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span>
            <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;cividis&quot;</span><span class="p">,</span>
            <span class="n">interpolation</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
            <span class="n">aspect</span><span class="o">=</span><span class="s2">&quot;equal&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Slice n. </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">SLICE</span><span class="si">}</span><span class="s2"> of masked object&quot;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s2">&quot;bold&quot;</span><span class="p">)</span>

        <span class="n">axcolor</span> <span class="o">=</span> <span class="s2">&quot;lightgoldenrodyellow&quot;</span>
        <span class="n">axSlider</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">([</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.65</span><span class="p">,</span> <span class="mf">0.03</span><span class="p">],</span> <span class="n">facecolor</span><span class="o">=</span><span class="n">axcolor</span><span class="p">)</span>
        <span class="n">slider</span> <span class="o">=</span> <span class="n">Slider</span><span class="p">(</span>
            <span class="n">axSlider</span><span class="p">,</span>
            <span class="s2">&quot;Slice&quot;</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="n">img_view</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">valinit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SLICE</span><span class="p">,</span>
            <span class="n">valstep</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="n">slice_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">slider</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            <span class="n">l</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">img_view</span><span class="p">[</span><span class="n">slice_index</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw_idle</span><span class="p">()</span>

        <span class="n">slider</span><span class="o">.</span><span class="n">on_changed</span><span class="p">(</span><span class="n">update</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">get_backend</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;agg&quot;</span><span class="p">:</span>
            <span class="c1"># set the backend to TkAgg</span>
            <span class="n">matplotlib</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s2">&quot;TkAgg&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="OCC_volume.plot_slice">
<a class="viewcode-back" href="../spline_volume.html#spline_volume.OCC_volume.plot_slice">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">SLICE</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">ASPECT</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot a specific slice of the given image.</span>

<span class="sd">        This function plots a specified slice of the input image using Matplotlib.</span>
<span class="sd">        It also provides an interactive slider to navigate through different slices.</span>

<span class="sd">        Args:</span>
<span class="sd">            image (SimpleITK.Image): The input image to be plotted.</span>
<span class="sd">            SLICE (int): The index of the slice to be plotted.</span>
<span class="sd">            title (str): The title of the plot.</span>
<span class="sd">            ASPECT (float): The aspect ratio for the plot.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">img_view</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetArrayViewFromImage</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="n">ASPECT</span><span class="p">,</span> <span class="n">ASPECT</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span>
            <span class="n">img_view</span><span class="p">[</span><span class="n">SLICE</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">&quot;equal&quot;</span>
        <span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s2">&quot;bold&quot;</span><span class="p">)</span>

        <span class="n">axcolor</span> <span class="o">=</span> <span class="s2">&quot;lightgoldenrodyellow&quot;</span>
        <span class="n">axSlider</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">([</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.65</span><span class="p">,</span> <span class="mf">0.03</span><span class="p">],</span> <span class="n">facecolor</span><span class="o">=</span><span class="n">axcolor</span><span class="p">)</span>
        <span class="n">slider</span> <span class="o">=</span> <span class="n">Slider</span><span class="p">(</span>
            <span class="n">axSlider</span><span class="p">,</span> <span class="s2">&quot;Slice&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">img_view</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">valinit</span><span class="o">=</span><span class="n">SLICE</span><span class="p">,</span> <span class="n">valstep</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>

        <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="n">slice_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">slider</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            <span class="n">l</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">img_view</span><span class="p">[</span><span class="n">slice_index</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw_idle</span><span class="p">()</span>

        <span class="n">slider</span><span class="o">.</span><span class="n">on_changed</span><span class="p">(</span><span class="n">update</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">get_backend</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;agg&quot;</span><span class="p">:</span>
            <span class="c1"># set the backend to TkAgg</span>
            <span class="n">matplotlib</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s2">&quot;TkAgg&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="OCC_volume.exec_thresholding">
<a class="viewcode-back" href="../spline_volume.html#spline_volume.OCC_volume.exec_thresholding">[docs]</a>
    <span class="k">def</span> <span class="nf">exec_thresholding</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">Image</span><span class="p">,</span> <span class="n">THRESHOLD_PARAM</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Image</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply binary thresholding to the given image.</span>

<span class="sd">        This function applies binary thresholding to the input image based on the</span>
<span class="sd">        specified threshold parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">            image (SimpleITK.Image): The input image to be thresholded.</span>
<span class="sd">            THRESHOLD_PARAM (List[float]): List of threshold parameters [INSIDE_VAL, OUTSIDE_VAL, LOWER_THRESH, UPPER_THRESH].</span>

<span class="sd">        Returns:</span>
<span class="sd">            SimpleITK.Image: The thresholded image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">btif</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">BinaryThresholdImageFilter</span><span class="p">()</span>
        <span class="n">btif</span><span class="o">.</span><span class="n">SetInsideValue</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">THRESHOLD_PARAM</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">btif</span><span class="o">.</span><span class="n">SetOutsideValue</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">THRESHOLD_PARAM</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">btif</span><span class="o">.</span><span class="n">SetLowerThreshold</span><span class="p">(</span><span class="n">THRESHOLD_PARAM</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">btif</span><span class="o">.</span><span class="n">SetUpperThreshold</span><span class="p">(</span><span class="n">THRESHOLD_PARAM</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">image_thr</span> <span class="o">=</span> <span class="n">btif</span><span class="o">.</span><span class="n">Execute</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">image_thr</span></div>


<div class="viewcode-block" id="OCC_volume.draw_contours">
<a class="viewcode-back" href="../spline_volume.html#spline_volume.OCC_volume.draw_contours">[docs]</a>
    <span class="k">def</span> <span class="nf">draw_contours</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">loc</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="s2">&quot;outer&quot;</span><span class="p">),</span> <span class="n">approximation</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the contours of an image.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (numpy.ndarray): The input image as a 2D numpy array.</span>
<span class="sd">            loc (str): The location of the contour. Can be &quot;outer&quot; or &quot;inner&quot;. Defaults to &quot;outer&quot;.</span>
<span class="sd">            approximation (bool): If True, contour is approximated using the Ramer-Douglas-Peucker (RDP) algorithm. Defaults to True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: The contour image as a 2D numpy array.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the location of the contour is not valid.</span>

<span class="sd">        Credits to:</span>
<span class="sd">            https://stackoverflow.com/questions/25733694/process-image-to-find-external-contour</span>

<span class="sd">        Docs:</span>
<span class="sd">            https://docs.opencv.org/2.4/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html</span>
<span class="sd">            https://learnopencv.com/convex-hull-using-opencv-in-python-and-c/</span>
<span class="sd">            https://doi.org/10.1016/0167-8655(82)90016-2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="mf">0.001</span>
        <span class="c1"># eps = 0.015</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">==</span> <span class="s2">&quot;outer&quot;</span><span class="p">:</span>
            <span class="n">_contours</span><span class="p">,</span> <span class="n">hierarchy</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">findContours</span><span class="p">(</span>
                <span class="n">img</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">cv2</span><span class="o">.</span><span class="n">RETR_EXTERNAL</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CHAIN_APPROX_SIMPLE</span>
            <span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">img</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">approximation</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">cnts</span> <span class="o">=</span> <span class="n">imutils</span><span class="o">.</span><span class="n">grab_contours</span><span class="p">((</span><span class="n">_contours</span><span class="p">,</span> <span class="n">hierarchy</span><span class="p">))</span>
                <span class="n">c</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cnts</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">contourArea</span><span class="p">)</span>
                <span class="n">peri</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">arcLength</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                <span class="n">approx</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">approxPolyDP</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">eps</span> <span class="o">*</span> <span class="n">peri</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                <span class="n">contour</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">drawContours</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="p">[</span><span class="n">approx</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># all contours, in white, with thickness 1</span>
                <span class="n">contour</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">drawContours</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">_contours</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">loc</span> <span class="o">==</span> <span class="s2">&quot;inner&quot;</span><span class="p">:</span>
            <span class="n">_contours</span><span class="p">,</span> <span class="n">hierarchy</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">findContours</span><span class="p">(</span>
                <span class="n">img</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">cv2</span><span class="o">.</span><span class="n">RETR_TREE</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CHAIN_APPROX_SIMPLE</span>
            <span class="p">)</span>
            <span class="n">inn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">img</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">approximation</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">cnts</span> <span class="o">=</span> <span class="n">imutils</span><span class="o">.</span><span class="n">grab_contours</span><span class="p">((</span><span class="n">_contours</span><span class="p">,</span> <span class="n">hierarchy</span><span class="p">))</span>
                <span class="n">c</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">cnts</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">contourArea</span><span class="p">)</span>
                <span class="n">peri</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">arcLength</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                <span class="n">approx</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">approxPolyDP</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">eps</span> <span class="o">*</span> <span class="n">peri</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                <span class="n">contour</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">drawContours</span><span class="p">(</span><span class="n">inn</span><span class="p">,</span> <span class="p">[</span><span class="n">approx</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">contour</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">drawContours</span><span class="p">(</span><span class="n">inn</span><span class="p">,</span> <span class="n">_contours</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The location of the contour is not valid. Please choose between &#39;outer&#39; and &#39;inner&#39;.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">contour</span></div>


<div class="viewcode-block" id="OCC_volume.get_binary_contour">
<a class="viewcode-back" href="../spline_volume.html#spline_volume.OCC_volume.get_binary_contour">[docs]</a>
    <span class="k">def</span> <span class="nf">get_binary_contour</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">Image</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Image</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate binary contours from the given image.</span>
<span class="sd">        https://itk.org/pipermail/community/2017-August/013464.html</span>

<span class="sd">        This function generates binary contours for each slice of the input image</span>
<span class="sd">        and joins them into a single 3D image.</span>

<span class="sd">        Args:</span>
<span class="sd">            image (SimpleITK.Image): The input image.</span>

<span class="sd">        Returns:</span>
<span class="sd">            SimpleITK.Image: The image with binary contours.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">img_thr_join</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">JoinSeries</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">sitk</span><span class="o">.</span><span class="n">BinaryContour</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="n">z</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">fullyConnected</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">GetSize</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">img_thr_join</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">PermuteAxes</span><span class="p">(</span><span class="n">img_thr_join</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">img_thr_join</span><span class="o">.</span><span class="n">SetSpacing</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">GetSpacing</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">img_thr_join</span></div>


<div class="viewcode-block" id="OCC_volume.get_draw_contour">
<a class="viewcode-back" href="../spline_volume.html#spline_volume.OCC_volume.get_draw_contour">[docs]</a>
    <span class="k">def</span> <span class="nf">get_draw_contour</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">Image</span><span class="p">,</span> <span class="n">loc</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="s2">&quot;outer&quot;</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract and draw contours from the given image.</span>

<span class="sd">        This function extracts and draws contours from the input image for each slice.</span>
<span class="sd">        The contours are then flipped and returned as a numpy array.</span>

<span class="sd">        Args:</span>
<span class="sd">            image (SimpleITK.Image): The input image.</span>
<span class="sd">            loc (str, optional): The location of the contour to be drawn. Default is &quot;outer&quot;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ndarray: The extracted and drawn contours.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">img_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">sitk</span><span class="o">.</span><span class="n">GetArrayFromImage</span><span class="p">(</span><span class="n">image</span><span class="p">),</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">contour_np</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">draw_contours</span><span class="p">(</span><span class="n">img_np</span><span class="p">[</span><span class="n">z</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">loc</span><span class="p">,</span> <span class="n">approximation</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">img_np</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="p">]</span>
        <span class="n">contour_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">contour_np</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">contour_np</span></div>


<div class="viewcode-block" id="OCC_volume.pad_image">
<a class="viewcode-back" href="../spline_volume.html#spline_volume.OCC_volume.pad_image">[docs]</a>
    <span class="k">def</span> <span class="nf">pad_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">Image</span><span class="p">,</span> <span class="n">iso_pad_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Image</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pads the input image with a constant value (background value) to increase its size.</span>
<span class="sd">        Padding is used to prevent having contours on the edges of the image,</span>
<span class="sd">        which would cause the spline fitting to fail.</span>
<span class="sd">        Padding is performed on the transverse plane only</span>
<span class="sd">        (image orientation is assumed to be z, y, x)</span>

<span class="sd">        Args:</span>
<span class="sd">            image (SimpleITK.Image): The input image to be padded.</span>
<span class="sd">            iso_pad_size (int): The size of the padding to be added to each dimension.</span>

<span class="sd">        Returns:</span>
<span class="sd">            SimpleITK.Image: The padded image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">constant</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sitk</span><span class="o">.</span><span class="n">GetArrayFromImage</span><span class="p">(</span><span class="n">image</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">image_thr</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">ConstantPad</span><span class="p">(</span>
            <span class="n">image</span><span class="p">,</span>
            <span class="p">(</span><span class="n">iso_pad_size</span><span class="p">,</span> <span class="n">iso_pad_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="p">(</span><span class="n">iso_pad_size</span><span class="p">,</span> <span class="n">iso_pad_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="n">constant</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">image_thr</span></div>


<div class="viewcode-block" id="OCC_volume.pad_and_plot">
<a class="viewcode-back" href="../spline_volume.html#spline_volume.OCC_volume.pad_and_plot">[docs]</a>
    <span class="k">def</span> <span class="nf">pad_and_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">Image</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pad the given image and optionally plot a slice of it.</span>

<span class="sd">        This function pads the input image with a specified padding size and</span>
<span class="sd">        optionally plots a specified slice of the padded image.</span>

<span class="sd">        Args:</span>
<span class="sd">            image (SimpleITK.Image): The input image to be padded.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ndarray: The padded image as a NumPy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ASPECT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ASPECT</span>
        <span class="n">SLICE</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SLICE</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Image size before padding: </span><span class="si">{</span><span class="n">image</span><span class="o">.</span><span class="n">GetSize</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">image_pad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad_image</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">iso_pad_size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Image size after padding: </span><span class="si">{</span><span class="n">image_pad</span><span class="o">.</span><span class="n">GetSize</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_plots</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_slice</span><span class="p">(</span>
                <span class="n">image_pad</span><span class="p">,</span> <span class="n">SLICE</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Padded Image on slice n. </span><span class="si">{</span><span class="n">SLICE</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ASPECT</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Padded Image</span><span class="se">\t\t\t</span><span class="s2">show_plots:</span><span class="se">\t</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">show_plots</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Image size after padding: </span><span class="si">{</span><span class="n">image_pad</span><span class="o">.</span><span class="n">GetSize</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">image_pad</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    def binary_threshold(self, img_path: str) -&gt; Tuple[ndarray, ndarray]:</span>
<span class="sd">        THRESHOLD_PARAM = [INSIDE_VAL, OUTSIDE_VAL, LOWER_THRESH, UPPER_THRESH]</span>
<span class="sd">        THRESHOLD_PARAM = self.THRESHOLD_PARAM</span>
<span class="sd">        ASPECT = self.ASPECT</span>
<span class="sd">        SLICE = self.SLICE</span>

<span class="sd">        if self.sitk_image is None:</span>
<span class="sd">            image = sitk.ReadImage(img_path)</span>
<span class="sd">        else:</span>
<span class="sd">            image = self.sitk_image</span>
<span class="sd">            image = sitk.PermuteAxes(image, [2, 0, 1])</span>
<span class="sd">            image.SetSpacing(self.sitk_image.GetSpacing())</span>

<span class="sd">        # Subsample the image for faster processing</span>
<span class="sd">        image = sitk.Shrink(image, [1, self.UNDERSAMPLING, self.UNDERSAMPLING])</span>

<span class="sd">        image_thr = self.exec_thresholding(image, THRESHOLD_PARAM)</span>

<span class="sd">        image_thr = self.pad_image(image_thr, iso_pad_size=10)</span>

<span class="sd">        if self.show_plots is True:</span>
<span class="sd">            self.plot_slice(</span>
<span class="sd">                image_thr, SLICE, f&quot;Padded Image on slice n. {SLICE}&quot;, ASPECT</span>
<span class="sd">            )</span>
<span class="sd">        else:</span>
<span class="sd">            self.logger.info(f&quot;Padded Image\t\t\tshow_plots:\t{self.show_plots}&quot;)</span>

<span class="sd">        img_thr_join = self.get_binary_contour(image_thr)</span>
<span class="sd">        self.spacing = image.GetSpacing()</span>

<span class="sd">        if self.show_plots is True:</span>
<span class="sd">            self.plot_slice(</span>
<span class="sd">                img_thr_join, SLICE, f&quot;Binary threshold on slice n. {SLICE}&quot;, ASPECT</span>
<span class="sd">            )</span>
<span class="sd">        else:</span>
<span class="sd">            self.logger.info(f&quot;Binary threshold\t\tshow_plots:\t{self.show_plots}&quot;)</span>

<span class="sd">        if self.phases &gt;= 1:</span>
<span class="sd">            outer_contour_np = self.get_draw_contour(img_thr_join, loc=&quot;outer&quot;)</span>
<span class="sd">            contour_ext = np.transpose(outer_contour_np, [2, 1, 0])</span>

<span class="sd">            if self.show_plots is True:</span>
<span class="sd">                outer_contour_sitk = sitk.GetImageFromArray(contour_ext)</span>
<span class="sd">                outer_contour_sitk.CopyInformation(image_thr)</span>

<span class="sd">                if self.phases == 1:</span>
<span class="sd">                    self.plot_slice(</span>
<span class="sd">                        outer_contour_sitk,</span>
<span class="sd">                        SLICE,</span>
<span class="sd">                        f&quot;Outer contour on slice n. {SLICE}&quot;,</span>
<span class="sd">                        ASPECT,</span>
<span class="sd">                    )</span>
<span class="sd">            else:</span>
<span class="sd">                self.logger.info(f&quot;Binary threshold\t\tshow_plots:\t{self.show_plots}&quot;)</span>

<span class="sd">        if self.phases == 2:</span>
<span class="sd">            inner_contour_np = self.get_draw_contour(img_thr_join, loc=&quot;inner&quot;)</span>
<span class="sd">            contour_int = np.transpose(inner_contour_np, [2, 1, 0])</span>

<span class="sd">            if self.show_plots is True:</span>
<span class="sd">                inner_contour_sitk = sitk.GetImageFromArray(contour_int)</span>
<span class="sd">                inner_contour_sitk.CopyInformation(image_thr)</span>
<span class="sd">                # put together both contours in sitk</span>
<span class="sd">                # contours_sitk = sitk.Compose(outer_contour_sitk, inner_contour_sitk)</span>

<span class="sd">                self.plot_slice(</span>
<span class="sd">                    inner_contour_sitk,</span>
<span class="sd">                    # contours_sitk,</span>
<span class="sd">                    SLICE,</span>
<span class="sd">                    f&quot;Inner contour on slice n. {SLICE}&quot;,</span>
<span class="sd">                    ASPECT,</span>
<span class="sd">                )</span>
<span class="sd">            else:</span>
<span class="sd">                self.logger.info(f&quot;Binary threshold\t\tshow_plots:\t{self.show_plots}&quot;)</span>

<span class="sd">        if self.phases &gt; 2:</span>
<span class="sd">            raise ValueError(</span>
<span class="sd">                &quot;The number of phases is greater than 2. Only biphasic materials are accepted (e.g. cort+trab).&quot;</span>
<span class="sd">            )</span>

<span class="sd">        img_size = image_thr.GetSize()</span>
<span class="sd">        img_spacing = image_thr.GetSpacing()</span>

<span class="sd">        xx = np.arange(</span>
<span class="sd">            0,</span>
<span class="sd">            img_size[1] * img_spacing[1],</span>
<span class="sd">            img_size[1] * img_spacing[1] / float(img_size[1]),</span>
<span class="sd">        )</span>
<span class="sd">        yy = np.arange(</span>
<span class="sd">            0,</span>
<span class="sd">            img_size[2] * img_spacing[2],</span>
<span class="sd">            img_size[2] * img_spacing[2] / float(img_size[2]),</span>
<span class="sd">        )</span>
<span class="sd">        coordsX, coordsY = np.meshgrid(xx, yy)</span>
<span class="sd">        self.coordsX = np.transpose(coordsX, [1, 0])</span>
<span class="sd">        self.coordsY = np.transpose(coordsY, [1, 0])</span>
<span class="sd">        return contour_ext, contour_int</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="OCC_volume.sort_xy">
<a class="viewcode-back" href="../spline_volume.html#spline_volume.OCC_volume.sort_xy">[docs]</a>
    <span class="k">def</span> <span class="nf">sort_xy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort x and y coordinates in a counterclockwise order.</span>
<span class="sd">        https://stackoverflow.com/questions/58377015/counterclockwise-sorting-of-x-y-data</span>

<span class="sd">        This function sorts the given x and y coordinates in a counterclockwise order</span>
<span class="sd">        based on their angles from the centroid.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (ndarray): The x-coordinates.</span>
<span class="sd">            y (ndarray): The y-coordinates.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[ndarray, ndarray]: The sorted x and y coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">y0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">y0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">/</span> <span class="n">r</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">/</span> <span class="n">r</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>

        <span class="n">x_sorted</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">y_sorted</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">x_sorted</span><span class="p">,</span> <span class="n">y_sorted</span></div>


<div class="viewcode-block" id="OCC_volume.plotly_add_traces">
<a class="viewcode-back" href="../spline_volume.html#spline_volume.OCC_volume.plotly_add_traces">[docs]</a>
    <span class="k">def</span> <span class="nf">plotly_add_traces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">original</span><span class="p">,</span> <span class="n">spline_interp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add traces to a Plotly figure for visualization.</span>

<span class="sd">        This function adds traces to a Plotly figure for visualizing the original</span>
<span class="sd">        and interpolated spline contours.</span>

<span class="sd">        Args:</span>
<span class="sd">            fig (plotly.graph_objs.Figure): The Plotly figure to add traces to.</span>
<span class="sd">            original (ndarray): The original contour points.</span>
<span class="sd">            spline_interp (ndarray): The interpolated spline contour points.</span>

<span class="sd">        Returns:</span>
<span class="sd">            plotly.graph_objs.Figure: The updated Plotly figure with added traces.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">add_traces</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">go</span><span class="o">.</span><span class="n">Scatter</span><span class="p">(</span>
                    <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;lines+markers&quot;</span><span class="p">,</span>
                    <span class="n">marker</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;Black&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span>
                    <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">line</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">px</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">qualitative</span><span class="o">.</span><span class="n">Dark2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">width</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
                    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Original&quot;</span><span class="p">,</span>
                    <span class="n">x</span><span class="o">=</span><span class="n">original</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                    <span class="n">y</span><span class="o">=</span><span class="n">original</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="p">),</span>
                <span class="n">go</span><span class="o">.</span><span class="n">Scatter</span><span class="p">(</span>
                    <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">line</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">px</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">qualitative</span><span class="o">.</span><span class="n">Dark2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">width</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span>
                    <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;B-spline order </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">x</span><span class="o">=</span><span class="n">spline_interp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                    <span class="n">y</span><span class="o">=</span><span class="n">spline_interp</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="p">),</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div>


<div class="viewcode-block" id="OCC_volume.plotly_makefig">
<a class="viewcode-back" href="../spline_volume.html#spline_volume.OCC_volume.plotly_makefig">[docs]</a>
    <span class="k">def</span> <span class="nf">plotly_makefig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finalize and display the Plotly figure with sliders.</span>

<span class="sd">        This function finalizes the Plotly figure by adding sliders for navigating</span>
<span class="sd">        through slices and displays the figure.</span>

<span class="sd">        Args:</span>
<span class="sd">            fig (plotly.graph_objs.Figure): The Plotly figure to be finalized and displayed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            plotly.graph_objs.Figure: The finalized Plotly figure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SLICING_COEFFICIENT</span><span class="p">]</span><span class="o">.</span><span class="n">visible</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Create and add slider</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacing</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slice_index</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">data</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">step</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;update&quot;</span><span class="p">,</span>
                    <span class="n">args</span><span class="o">=</span><span class="p">[</span>
                        <span class="p">{</span><span class="s2">&quot;visible&quot;</span><span class="p">:</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">data</span><span class="p">)},</span>
                        <span class="p">{</span>
                            <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;Slice position </span><span class="si">{</span><span class="p">(((</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">height</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> mm&quot;</span>
                        <span class="p">},</span>
                    <span class="p">],</span>
                    <span class="n">label</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1"># Toggle i&#39;th trace to &quot;visible&quot;</span>
                <span class="n">step</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;visible&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">step</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;visible&quot;</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>

        <span class="n">sliders</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">dict</span><span class="p">(</span>
                <span class="n">active</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                <span class="n">currentvalue</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;prefix&quot;</span><span class="p">:</span> <span class="s2">&quot;Slice: &quot;</span><span class="p">,</span> <span class="s2">&quot;suffix&quot;</span><span class="p">:</span> <span class="s2">&quot; [-]&quot;</span><span class="p">},</span>
                <span class="n">pad</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;t&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">},</span>
                <span class="n">steps</span><span class="o">=</span><span class="n">steps</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">]</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">update_layout</span><span class="p">(</span><span class="n">sliders</span><span class="o">=</span><span class="n">sliders</span><span class="p">,</span> <span class="n">autosize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">800</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">800</span><span class="p">)</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">add_annotation</span><span class="p">(</span>
            <span class="n">text</span><span class="o">=</span><span class="s2">&quot;Slice representation through splines&quot;</span><span class="p">,</span>
            <span class="n">xref</span><span class="o">=</span><span class="s2">&quot;paper&quot;</span><span class="p">,</span>
            <span class="n">yref</span><span class="o">=</span><span class="s2">&quot;paper&quot;</span><span class="p">,</span>
            <span class="n">x</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
            <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">showarrow</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">font</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">18</span><span class="p">,</span> <span class="n">family</span><span class="o">=</span><span class="s2">&quot;stix&quot;</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">update_xaxes</span><span class="p">(</span><span class="nb">range</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">])</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">update_yaxes</span><span class="p">(</span><span class="nb">range</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">])</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">fig</span></div>


<div class="viewcode-block" id="OCC_volume.check_orient">
<a class="viewcode-back" href="../spline_volume.html#spline_volume.OCC_volume.check_orient">[docs]</a>
    <span class="k">def</span> <span class="nf">check_orient</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">direction</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Author: Simone Poncioni, MSB</span>
<span class="sd">        Date: 18.08.2022</span>
<span class="sd">        Functionality: Orient all array in the same direction (cw or ccw)</span>
<span class="sd">        (Sometimes planes would reorient in opposite direction, making them unsuitable for interplane connectivity)</span>

<span class="sd">        Args:</span>
<span class="sd">        x = 1D-arr (x coords of points)</span>
<span class="sd">        y = 1D-arr (y coords of points)</span>
<span class="sd">        directions: 1 = cw, 2 = ccw</span>

<span class="sd">        Returns:</span>
<span class="sd">        x_o = reoriented x 1D-arr</span>
<span class="sd">        y_o = reoriented y 1D-arr</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug_orientation</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Desired direction: cw&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug_orientation</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Not flipping&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="n">x_o</span> <span class="o">=</span> <span class="n">x</span>
                <span class="n">y_o</span> <span class="o">=</span> <span class="n">y</span>
            <span class="k">elif</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug_orientation</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Flipping&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="n">x_o</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">y_o</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Something went wrong while flipping the array&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug_orientation</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Desired direction: ccw&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug_orientation</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Not flipping&quot;</span><span class="p">)</span>
                <span class="n">x_o</span> <span class="o">=</span> <span class="n">x</span>
                <span class="n">y_o</span> <span class="o">=</span> <span class="n">y</span>
            <span class="k">elif</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug_orientation</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Flipping&quot;</span><span class="p">)</span>
                <span class="n">x_o</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">y_o</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Something went wrong while flipping the array&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x_o</span><span class="p">,</span> <span class="n">y_o</span></div>


<div class="viewcode-block" id="OCC_volume.sort_mahalanobis">
<a class="viewcode-back" href="../spline_volume.html#spline_volume.OCC_volume.sort_mahalanobis">[docs]</a>
    <span class="k">def</span> <span class="nf">sort_mahalanobis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort points based on pairwise distances to form a continuous contour.</span>

<span class="sd">        This function sorts the given data points based on pairwise distances to</span>
<span class="sd">        form a continuous contour, ensuring no self-intersections.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (ndarray): The data points to be sorted.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[ndarray, ndarray]: The sorted x and y coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Compute pairwise distances between all points in the contour</span>
        <span class="n">dist_matrix</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># Initialize variables</span>
        <span class="n">n_points</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">sorted_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">sorted_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">visited</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Iterate over remaining points in the contour</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_points</span><span class="p">):</span>
            <span class="c1"># Compute distances from the previous point to all unvisited points</span>
            <span class="n">dist_to_prev</span> <span class="o">=</span> <span class="n">dist_matrix</span><span class="p">[</span><span class="n">sorted_indices</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="p">:]</span>
            <span class="n">dist_to_prev</span><span class="p">[</span><span class="n">visited</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

            <span class="c1"># Find the closest unvisited point to the previous point</span>
            <span class="n">closest_unvisited</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist_to_prev</span><span class="p">)</span>
            <span class="n">sorted_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">closest_unvisited</span>
            <span class="n">visited</span><span class="p">[</span><span class="n">closest_unvisited</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Reorder the data based on the sorted indices</span>
        <span class="n">sorted_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">sorted_indices</span><span class="p">]</span>

        <span class="c1"># Ensure the contour does not self-intersect</span>
        <span class="c1"># sorted_data = self.remove_self_intersections(sorted_data)</span>
        <span class="k">return</span> <span class="n">sorted_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sorted_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="OCC_volume.sort_surface">
<a class="viewcode-back" href="../spline_volume.html#spline_volume.OCC_volume.sort_surface">[docs]</a>
    <span class="k">def</span> <span class="nf">sort_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_slice</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort surface points in a clockwise direction and with Mahalanobis distance to add robustness</span>


<span class="sd">        Args:</span>
<span class="sd">            slices (int): slice number</span>

<span class="sd">        Returns:</span>
<span class="sd">            self.xy_sorted_closed (numpy.ndarray): xy array of sorted points</span>
<span class="sd">            self.x_mahanalobis (numpy.ndarray): x array of sorted points with mahalanobis distance</span>
<span class="sd">            self.y_mahanalobis (numpy.ndarray): y array of sorted points with mahalanobis distance</span>
<span class="sd">            self.xnew (numpy.ndarray): x array of sorted points interpolated with bspline and in the same direction</span>
<span class="sd">            self.ynew (numpy.ndarray): y array of sorted points interpolated with bspline and in the same direction</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordsX</span><span class="p">[</span><span class="n">image_slice</span> <span class="o">==</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span> <span class="p">::</span> <span class="bp">self</span><span class="o">.</span><span class="n">UNDERSAMPLING</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordsY</span><span class="p">[</span><span class="n">image_slice</span> <span class="o">==</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span> <span class="p">::</span> <span class="bp">self</span><span class="o">.</span><span class="n">UNDERSAMPLING</span><span class="p">]</span>

        <span class="n">x_s</span><span class="p">,</span> <span class="n">y_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort_xy</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">xy_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">x_s</span><span class="p">,</span> <span class="n">y_s</span><span class="p">]</span>
        <span class="n">xy_sorted_closed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">xy_sorted</span><span class="p">,</span> <span class="n">xy_sorted</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">x_mahalanobis</span><span class="p">,</span> <span class="n">y_mahalanobis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort_mahalanobis</span><span class="p">(</span><span class="n">xy_sorted</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="n">x_mahalanobis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_mahalanobis</span><span class="p">,</span> <span class="n">x_mahalanobis</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">y_mahalanobis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_mahalanobis</span><span class="p">,</span> <span class="n">y_mahalanobis</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">x_copy</span> <span class="o">=</span> <span class="n">x_mahalanobis</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">y_copy</span> <span class="o">=</span> <span class="n">y_mahalanobis</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">BNDS</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1"># was 5, then 10</span>
        <span class="n">x_bnds</span><span class="p">,</span> <span class="n">y_bnds</span> <span class="o">=</span> <span class="n">x_copy</span><span class="p">[</span><span class="n">BNDS</span><span class="p">:</span><span class="o">-</span><span class="n">BNDS</span><span class="p">],</span> <span class="n">y_copy</span><span class="p">[</span><span class="n">BNDS</span><span class="p">:</span><span class="o">-</span><span class="n">BNDS</span><span class="p">]</span>
        <span class="c1"># find the knot points</span>
        <span class="n">tckp</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">splprep</span><span class="p">(</span>
            <span class="p">[</span><span class="n">x_bnds</span><span class="p">,</span> <span class="n">y_bnds</span><span class="p">],</span>
            <span class="n">s</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span>
            <span class="n">k</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span>
            <span class="n">per</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">ub</span><span class="o">=</span><span class="p">[</span><span class="n">x_copy</span><span class="p">,</span> <span class="n">y_copy</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">ue</span><span class="o">=</span><span class="p">[</span><span class="n">x_copy</span><span class="p">,</span> <span class="n">y_copy</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">quiet</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># evaluate spline, including interpolated points</span>
        <span class="n">xnew</span><span class="p">,</span> <span class="n">ynew</span> <span class="o">=</span> <span class="n">splev</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">INTERP_POINTS_S</span><span class="p">),</span> <span class="n">tckp</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">xnew</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xnew</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-08</span><span class="p">):</span>
            <span class="n">xnew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xnew</span><span class="p">,</span> <span class="n">xnew</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">ynew</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ynew</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-08</span><span class="p">):</span>
            <span class="n">ynew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ynew</span><span class="p">,</span> <span class="n">ynew</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># Sanity check to ensure directionality of sorting in cw- or ccw-direction</span>
        <span class="n">xnew_oriented</span><span class="p">,</span> <span class="n">ynew_oriented</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_orient</span><span class="p">(</span><span class="n">xnew</span><span class="p">,</span> <span class="n">ynew</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">xy_sorted_closed</span><span class="p">,</span>
            <span class="n">xnew_oriented</span><span class="p">,</span>
            <span class="n">ynew_oriented</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="OCC_volume.input_sanity_check">
<a class="viewcode-back" href="../spline_volume.html#spline_volume.OCC_volume.input_sanity_check">[docs]</a>
    <span class="k">def</span> <span class="nf">input_sanity_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext_contour_s</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">int_contour_s</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sanity check for the input data before cortical sanity check</span>

<span class="sd">        Args:</span>
<span class="sd">            ext_contour_s (np.ndarray): array of external contour points</span>
<span class="sd">            int_contour_s (np.ndarray): array of internal contour points</span>

<span class="sd">        Returns:</span>
<span class="sd">            ext_contour_s (np.ndarray): array of external contour points</span>
<span class="sd">            with defined shape and structure (no duplicates, closed contour)</span>

<span class="sd">            int_contour_s (np.ndarray): array of internal contour points</span>
<span class="sd">            with defined shape and structure (no duplicates, closed contour)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># sanity check of input data ext_contour_s and int_contour_s</span>
        <span class="c1"># make sure that arr[0] is the same as arr[-1]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">int_contour_s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">int_contour_s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-08</span><span class="p">):</span>
            <span class="c1"># append first element to the end of the array</span>
            <span class="n">int_contour_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">int_contour_s</span><span class="p">,</span> <span class="p">[</span><span class="n">int_contour_s</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># if arr[0] is equal to arr[1] then remove the first element</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">ext_contour_s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ext_contour_s</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-08</span><span class="p">):</span>
            <span class="n">ext_contour_s</span> <span class="o">=</span> <span class="n">ext_contour_s</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">int_contour_s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">int_contour_s</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-08</span><span class="p">):</span>
            <span class="n">int_contour_s</span> <span class="o">=</span> <span class="n">int_contour_s</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="c1"># if arr[-1] is equal to arr[-2] then remove the last element</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">ext_contour_s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ext_contour_s</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-08</span><span class="p">):</span>
            <span class="n">ext_contour_s</span> <span class="o">=</span> <span class="n">ext_contour_s</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">int_contour_s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">int_contour_s</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-08</span><span class="p">):</span>
            <span class="n">int_contour_s</span> <span class="o">=</span> <span class="n">int_contour_s</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">ext_contour_s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ext_contour_s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-08</span><span class="p">):</span>
            <span class="c1"># append first element to the end of the array</span>
            <span class="n">ext_contour_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ext_contour_s</span><span class="p">,</span> <span class="p">[</span><span class="n">ext_contour_s</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># check that shape of ext_contour_s and int_contour_s are the same</span>
        <span class="k">if</span> <span class="n">ext_contour_s</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">int_contour_s</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Error in the shape of the external and internal contours of the slice:</span><span class="se">\t</span><span class="si">{</span><span class="nb">slice</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">90</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ext_contour_s</span><span class="p">,</span> <span class="n">int_contour_s</span></div>


<div class="viewcode-block" id="OCC_volume.output_sanity_check">
<a class="viewcode-back" href="../spline_volume.html#spline_volume.OCC_volume.output_sanity_check">[docs]</a>
    <span class="k">def</span> <span class="nf">output_sanity_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_contour</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">contour_s</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform a sanity check on the output contours.</span>

<span class="sd">        This function checks that the external and internal contours have the same</span>
<span class="sd">        structure and shape as before the sanity check. It ensures that the contours</span>
<span class="sd">        do not have duplicate points and have the correct shape.</span>

<span class="sd">        Args:</span>
<span class="sd">            initial_contour (ndarray): The initial contour points.</span>
<span class="sd">            contour_s (ndarray): The contour points after the sanity check.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ndarray: The corrected contour points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">initial_contour</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">initial_contour</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-08</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;External contour has a duplicate first point&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">contour_s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">contour_s</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-08</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;New external contour does not have a duplicate first point&quot;</span>
                <span class="p">)</span>
                <span class="n">contour_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">contour_s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">contour_s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;New external contour now has a duplicate first point&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">initial_contour</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">initial_contour</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;External contour has a duplicate last point&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">contour_s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">contour_s</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-08</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;New external contour does not have a duplicate last point&quot;</span>
                <span class="p">)</span>
                <span class="n">contour_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">contour_s</span><span class="p">,</span> <span class="p">[</span><span class="n">contour_s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;New external contour now has a duplicate last point&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">initial_contour</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">contour_s</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;External contour has a different shape than the initial contour&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                <span class="s2">&quot;External contour has the same shape as before csc.CorticalSanityCheck&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">contour_s</span></div>


    <span class="k">def</span> <span class="nf">_pnts_on_line_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">is_percent</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>  <span class="c1"># densify by distance</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add points at a fixed spacing to a line.</span>
<span class="sd">        https://stackoverflow.com/questions/64995977/generating-equidistance-points-along-the-boundary-of-a-polygon-but-cw-ccw</span>

<span class="sd">        This function adds points at a fixed spacing to an array representing a line.</span>
<span class="sd">        The spacing can be specified as a fixed distance or as a percentage of the</span>
<span class="sd">        total length.</span>

<span class="sd">        Args:</span>
<span class="sd">            a (ndarray): A sequence of points representing the line.</span>
<span class="sd">            spacing (float): The spacing between the points to be added.</span>
<span class="sd">            is_percent (bool, optional): Whether to express the spacing as a percentage of the total length. Default is False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ndarray: The line with added points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># segments</span>
        <span class="n">dxdy</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># coordinate differences</span>
        <span class="n">leng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ij,ij-&gt;i&quot;</span><span class="p">,</span> <span class="n">dxdy</span><span class="p">,</span> <span class="n">dxdy</span><span class="p">))</span>  <span class="c1"># segment lengths</span>
        <span class="k">if</span> <span class="n">is_percent</span><span class="p">:</span>  <span class="c1"># as percentage</span>
            <span class="n">spacing</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">spacing</span><span class="p">)</span>
            <span class="n">spacing</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">spacing</span> <span class="o">/</span> <span class="mi">100</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="n">steps</span> <span class="o">=</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">leng</span><span class="p">)</span> <span class="o">*</span> <span class="n">spacing</span><span class="p">)</span> <span class="o">/</span> <span class="n">leng</span>  <span class="c1"># step distance</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">steps</span> <span class="o">=</span> <span class="n">leng</span> <span class="o">/</span> <span class="n">spacing</span>  <span class="c1"># step distance</span>
        <span class="n">deltas</span> <span class="o">=</span> <span class="n">dxdy</span> <span class="o">/</span> <span class="p">(</span><span class="n">steps</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># coordinate steps</span>
        <span class="n">pnts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">N</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;O&quot;</span><span class="p">)</span>  <span class="c1"># construct an `O` array</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>  <span class="c1"># cycle through the segments and make</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">steps</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>  <span class="c1"># the new points</span>
            <span class="n">pnts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">num</span><span class="p">,</span> <span class="n">num</span><span class="p">))</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">deltas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">a0</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># add the final point and concatenate</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="o">*</span><span class="n">pnts</span><span class="p">,</span> <span class="n">a0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<div class="viewcode-block" id="OCC_volume.volume_splines">
<a class="viewcode-back" href="../spline_volume.html#spline_volume.OCC_volume.volume_splines">[docs]</a>
    <span class="k">def</span> <span class="nf">volume_splines</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate splines for cortical and trabecular regions.</span>

<span class="sd">        This function processes the input image to generate volume splines for the</span>
<span class="sd">        cortical and trabecular regions. It includes steps for padding the image,</span>
<span class="sd">        extracting contours, and optionally plotting the results.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[ndarray, ndarray]: Arrays of cortical external and internal contours.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">contour_ext_fig</span><span class="p">,</span> <span class="n">contour_int_fig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad_and_plot</span><span class="p">(</span><span class="n">img_path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">img_path</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">slice_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
            <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">contour_ext_fig</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">SLICING_COEFFICIENT</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_plots</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Figure</span><span class="p">(</span><span class="n">layout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">layout</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Volume_splines</span><span class="se">\t\t</span><span class="s2">show_plots:</span><span class="se">\t</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">show_plots</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">img_contours_ext</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetImageFromArray</span><span class="p">(</span><span class="n">contour_ext_fig</span><span class="p">,</span> <span class="n">isVector</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">image_data_ext</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span>
                <span class="n">sitk</span><span class="o">.</span><span class="n">GetArrayViewFromImage</span><span class="p">(</span><span class="n">img_contours_ext</span><span class="p">),</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">img_contours_int</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetImageFromArray</span><span class="p">(</span><span class="n">contour_int_fig</span><span class="p">,</span> <span class="n">isVector</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">image_data_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span>
                <span class="n">sitk</span><span class="o">.</span><span class="n">GetArrayViewFromImage</span><span class="p">(</span><span class="n">img_contours_int</span><span class="p">),</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="n">contour_ext</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">contour_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">image_slice_ext</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_slice</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slice_index</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Slice:</span><span class="se">\t</span><span class="si">{</span><span class="n">_slice</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">image_slice_ext</span> <span class="o">=</span> <span class="n">image_data_ext</span><span class="p">[</span><span class="n">_slice</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">original</span><span class="p">,</span> <span class="n">cortical_ext_x</span><span class="p">,</span> <span class="n">cortical_ext_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort_surface</span><span class="p">(</span>
                    <span class="n">image_slice_ext</span>
                <span class="p">)</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cortical_ext_x</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spacing</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">_slice</span><span class="p">)</span>
                <span class="n">contour_ext</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">contour_ext</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">cortical_ext_x</span><span class="p">,</span> <span class="n">cortical_ext_y</span><span class="p">,</span> <span class="n">z</span><span class="p">]</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_plots</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="n">fig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plotly_add_traces</span><span class="p">(</span>
                            <span class="n">fig</span><span class="p">,</span> <span class="n">original</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">contour_ext</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">contour_ext</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">fig</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Phases is not &gt;= 1: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">image_slice_int</span> <span class="o">=</span> <span class="n">image_data_int</span><span class="p">[</span><span class="n">_slice</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">original</span><span class="p">,</span> <span class="n">cortical_int_x</span><span class="p">,</span> <span class="n">cortical_int_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort_surface</span><span class="p">(</span>
                    <span class="n">image_slice_int</span>
                <span class="p">)</span>
                <span class="n">contour_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">contour_int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">cortical_int_x</span><span class="p">,</span> <span class="n">cortical_int_y</span><span class="p">,</span> <span class="n">z</span><span class="p">]</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_plots</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="n">fig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plotly_add_traces</span><span class="p">(</span>
                            <span class="n">fig</span><span class="p">,</span> <span class="n">original</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">cortical_int_x</span><span class="p">,</span> <span class="n">cortical_int_y</span><span class="p">,</span> <span class="n">z</span><span class="p">]</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">fig</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Phases =/= 2: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_plots</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plotly_makefig</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_plots</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">contour_ext</span> <span class="o">=</span> <span class="n">contour_ext</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">contour_int</span> <span class="o">=</span> <span class="n">contour_int</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">contour_ext</span><span class="p">,</span> <span class="n">contour_int</span></div>


<div class="viewcode-block" id="OCC_volume.guess">
<a class="viewcode-back" href="../spline_volume.html#spline_volume.OCC_volume.guess">[docs]</a>
    <span class="k">def</span> <span class="nf">guess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Do an ordinary spline fit to provide knots&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">splrep</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">)</span></div>


<div class="viewcode-block" id="OCC_volume.err">
<a class="viewcode-back" href="../spline_volume.html#spline_volume.OCC_volume.err">[docs]</a>
    <span class="k">def</span> <span class="nf">err</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The error function to minimize&quot;&quot;&quot;</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">splev</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;...i,...i&quot;</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">diff</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">diff</span> <span class="o">*</span> <span class="n">diff</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span></div>


<div class="viewcode-block" id="OCC_volume.spline_neumann">
<a class="viewcode-back" href="../spline_volume.html#spline_volume.OCC_volume.spline_neumann">[docs]</a>
    <span class="k">def</span> <span class="nf">spline_neumann</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform cubic spline interpolation with Neumann boundary conditions.</span>

<span class="sd">        This function performs cubic spline interpolation on the given data points</span>
<span class="sd">        (x, y) with Neumann boundary conditions, ensuring zero slope at the first</span>
<span class="sd">        point. It uses the `scipy.optimize.minimize` function to optimize the spline</span>
<span class="sd">        coefficients under the specified constraints.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (ndarray): The x-coordinates of the data points.</span>
<span class="sd">            y (ndarray): The y-coordinates of the data points.</span>
<span class="sd">            k (int, optional): The degree of the spline. Default is 3.</span>
<span class="sd">            s (float, optional): Smoothing factor. Default is 0.</span>
<span class="sd">            w (ndarray, optional): Weights for spline fitting. Default is None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            UnivariateSpline: The resulting spline with Neumann boundary conditions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t</span><span class="p">,</span> <span class="n">c0</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">guess</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># point at which zero slope is required</span>
        <span class="n">con</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;eq&quot;</span><span class="p">,</span>
            <span class="s2">&quot;fun&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">splev</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">der</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
        <span class="p">}</span>
        <span class="n">opt</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">err</span><span class="p">,</span> <span class="n">c0</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">w</span><span class="p">),</span> <span class="n">constraints</span><span class="o">=</span><span class="n">con</span><span class="p">)</span>
        <span class="n">copt</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">x</span>
        <span class="k">return</span> <span class="n">UnivariateSpline</span><span class="o">.</span><span class="n">_from_tck</span><span class="p">((</span><span class="n">t</span><span class="p">,</span> <span class="n">copt</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span></div>


<div class="viewcode-block" id="OCC_volume.interpolate_vertical_lines_3d">
<a class="viewcode-back" href="../spline_volume.html#spline_volume.OCC_volume.interpolate_vertical_lines_3d">[docs]</a>
    <span class="k">def</span> <span class="nf">interpolate_vertical_lines_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line_sets</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        https://stackoverflow.com/questions/32046582/spline-with-constraints-at-border</span>
<span class="sd">        Interpolate vertical lines in 3D using cubic splines.</span>

<span class="sd">        This function performs cubic spline interpolation on the given vertical line sets</span>
<span class="sd">        with Neumann boundary conditions. It generates new Z values for interpolation and</span>
<span class="sd">        returns the interpolated points.</span>

<span class="sd">        Args:</span>
<span class="sd">            line_sets (List[List[ndarray]]): List of vertical line sets.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ndarray: Array of interpolated points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">interpolated_lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">line_sets</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

            <span class="c1"># Check for NaN or Inf values</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">line</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">line</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data contains NaN or Inf values.&quot;</span><span class="p">)</span>

            <span class="c1"># Check for duplicate points</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Insufficient unique data points for cubic spline interpolation.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Sort by Z-values</span>
            <span class="n">line_sorted_by_z</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">line</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])]</span>
            <span class="n">x_sorted</span> <span class="o">=</span> <span class="n">line_sorted_by_z</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">y_sorted</span> <span class="o">=</span> <span class="n">line_sorted_by_z</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">z_sorted</span> <span class="o">=</span> <span class="n">line_sorted_by_z</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>

            <span class="c1"># Perform cubic spline interpolation with Neumann boundary conditions</span>
            <span class="n">splrep_eval_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline_neumann</span><span class="p">(</span><span class="n">z_sorted</span><span class="p">,</span> <span class="n">x_sorted</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mf">1e6</span><span class="p">)</span>
            <span class="n">splrep_eval_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline_neumann</span><span class="p">(</span><span class="n">z_sorted</span><span class="p">,</span> <span class="n">y_sorted</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mf">1e6</span><span class="p">)</span>

            <span class="c1"># Generate new Z values for interpolation</span>
            <span class="n">znew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">z_sorted</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">z_sorted</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">SLICING_COEFFICIENT</span><span class="p">)</span>
            <span class="n">xnew</span> <span class="o">=</span> <span class="n">splrep_eval_x</span><span class="p">(</span><span class="n">znew</span><span class="p">)</span>
            <span class="n">ynew</span> <span class="o">=</span> <span class="n">splrep_eval_y</span><span class="p">(</span><span class="n">znew</span><span class="p">)</span>

            <span class="n">interpolated_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">xnew</span><span class="p">,</span> <span class="n">ynew</span><span class="p">,</span> <span class="n">znew</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="n">all_points_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">interpolated_lines</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Plot final interpolated points</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_plots</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                <span class="n">all_points_array</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="n">all_points_array</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Interpolated Points&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Interpolated Points&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">all_points_array</span></div>


<div class="viewcode-block" id="OCC_volume.classify_and_store_contours">
<a class="viewcode-back" href="../spline_volume.html#spline_volume.OCC_volume.classify_and_store_contours">[docs]</a>
    <span class="k">def</span> <span class="nf">classify_and_store_contours</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">slice_idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Classify and store contours from a given slice of the mask.</span>

<span class="sd">        This function finds contours in the specified slice of the mask and classifies</span>
<span class="sd">        the first contour as the outer contour and the second contour (if present) as</span>
<span class="sd">        the inner contour.</span>

<span class="sd">        Args:</span>
<span class="sd">            mask (ndarray): The 3D mask array from which contours are to be extracted.</span>
<span class="sd">            slice_idx (int): The index of the slice to be processed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[ndarray, ndarray]: The outer and inner contours.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">contours</span> <span class="o">=</span> <span class="n">find_contours</span><span class="p">(</span><span class="n">mask</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">slice_idx</span><span class="p">])</span>  <span class="c1"># , level=0.5)</span>
        <span class="k">if</span> <span class="n">contours</span><span class="p">:</span>
            <span class="n">outer_contours</span> <span class="o">=</span> <span class="n">contours</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># First contour as outer</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">contours</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">inner_contours</span> <span class="o">=</span> <span class="n">contours</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Second contour as inner</span>
        <span class="k">return</span> <span class="n">outer_contours</span><span class="p">,</span> <span class="n">inner_contours</span></div>


<div class="viewcode-block" id="OCC_volume.evaluate_bspline">
<a class="viewcode-back" href="../spline_volume.html#spline_volume.OCC_volume.evaluate_bspline">[docs]</a>
    <span class="k">def</span> <span class="nf">evaluate_bspline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">contour</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate a B-spline for the given contour.</span>

<span class="sd">        This function fits a B-spline to the given contour points and evaluates the</span>
<span class="sd">        spline to generate new interpolated points. The spline is closed by appending</span>
<span class="sd">        the first point to the end of the new points.</span>

<span class="sd">        Args:</span>
<span class="sd">            contour (ndarray): The contour points to be fitted with a B-spline.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[ndarray, ndarray]: The x and y coordinates of the interpolated B-spline points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tckp</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">splprep</span><span class="p">(</span>
            <span class="p">[</span><span class="n">contour</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">contour</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]],</span>
            <span class="n">s</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span>
            <span class="n">k</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span>
            <span class="n">per</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">ub</span><span class="o">=</span><span class="p">[</span><span class="n">contour</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">contour</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span>
            <span class="n">ue</span><span class="o">=</span><span class="p">[</span><span class="n">contour</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">contour</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span>
            <span class="n">quiet</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">xnew</span><span class="p">,</span> <span class="n">ynew</span> <span class="o">=</span> <span class="n">splev</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">INTERP_POINTS_S</span><span class="p">),</span> <span class="n">tckp</span><span class="p">)</span>
        <span class="n">xnew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xnew</span><span class="p">,</span> <span class="n">xnew</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ynew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ynew</span><span class="p">,</span> <span class="n">ynew</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">xnew</span><span class="p">,</span> <span class="n">ynew</span></div>


<div class="viewcode-block" id="OCC_volume.calculate_outer_offset">
<a class="viewcode-back" href="../spline_volume.html#spline_volume.OCC_volume.calculate_outer_offset">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_outer_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">contour</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the outer offset of a given contour.</span>

<span class="sd">        This function calculates the outer offset of the given contour by buffering</span>
<span class="sd">        the contour with a negative offset. It handles cases where multiple geometries</span>
<span class="sd">        are created during buffering and retains the largest one.</span>

<span class="sd">        Args:</span>
<span class="sd">            contour (ndarray): The input contour.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ndarray: The offset contour.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">MIN_THICKNESS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MIN_THICKNESS</span>
        <span class="n">contour</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">contour</span><span class="p">)[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="c1"># Assuming the contour is (x, y, z) and we only need (x, y)</span>
        <span class="n">outer_polygon</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">contour</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">MIN_THICKNESS</span><span class="p">)</span>
        <span class="n">buffered_polygon</span> <span class="o">=</span> <span class="n">outer_polygon</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="o">-</span><span class="n">offset</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">buffered_polygon</span><span class="o">.</span><span class="n">geoms</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># sometimes some spurious polygons are created, assuming that we want to keep the largest one</span>
                <span class="n">polygons</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">buffered_polygon</span><span class="o">.</span><span class="n">geoms</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Buffered polygon has more than one geometry: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">polygons</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="c1"># if difference of area is big, then discard the small polygons</span>
                <span class="n">areas</span> <span class="o">=</span> <span class="p">[</span><span class="n">polygon</span><span class="o">.</span><span class="n">area</span> <span class="k">for</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="n">polygons</span><span class="p">]</span>
                <span class="n">max_area</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">areas</span><span class="p">)</span>
                <span class="c1"># assuming that the largest polygon is the correct one</span>
                <span class="n">buffered_polygon</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">polygon</span> <span class="k">for</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="n">polygons</span> <span class="k">if</span> <span class="n">polygon</span><span class="o">.</span><span class="n">area</span> <span class="o">==</span> <span class="n">max_area</span>
                <span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="n">offset_polygon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">buffered_polygon</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">offset_polygon</span></div>


<div class="viewcode-block" id="OCC_volume.check_inner_offset">
<a class="viewcode-back" href="../spline_volume.html#spline_volume.OCC_volume.check_inner_offset">[docs]</a>
    <span class="k">def</span> <span class="nf">check_inner_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outer_polygon</span><span class="p">,</span> <span class="n">inn_contour</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check and adjust the inner contour based on the outer polygon.</span>

<span class="sd">        This function checks if the points of the inner contour are within the outer</span>
<span class="sd">        polygon. If not, it adjusts the points to the closest points on the outer polygon.</span>

<span class="sd">        Args:</span>
<span class="sd">            outer_polygon (ndarray): The outer polygon contour.</span>
<span class="sd">            inn_contour (ndarray): The inner contour points.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ndarray: The adjusted inner contour points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">outer_polygon</span> <span class="o">=</span> <span class="n">shpg</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">outer_polygon</span><span class="p">)</span>
        <span class="n">outer_contour</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">outer_polygon</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">inn_contour</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">inn_contour</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">is_inside_shpg</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">shpg</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">point</span><span class="p">)</span><span class="o">.</span><span class="n">within</span><span class="p">(</span><span class="n">outer_polygon</span><span class="p">)</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">inn_contour</span>
        <span class="p">]</span>
        <span class="n">is_inside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">is_inside_shpg</span><span class="p">,</span> <span class="n">is_inside_shpg</span><span class="p">]</span>
        <span class="n">closest_points</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">outer_contour</span><span class="p">[</span><span class="n">spatial</span><span class="o">.</span><span class="n">KDTree</span><span class="p">(</span><span class="n">outer_contour</span><span class="p">)</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">point</span><span class="p">)[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">inn_contour</span>
        <span class="p">]</span>
        <span class="n">closest_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">closest_points</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">dst</span><span class="o">=</span><span class="n">inn_contour</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="n">closest_points</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">is_inside</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">inn_contour</span></div>


<div class="viewcode-block" id="OCC_volume.process_slice">
<a class="viewcode-back" href="../spline_volume.html#spline_volume.OCC_volume.process_slice">[docs]</a>
    <span class="k">def</span> <span class="nf">process_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">slice_idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process a single slice to classify and store contours.</span>

<span class="sd">        This function processes a single slice of the input mask to classify and store</span>
<span class="sd">        the outer and inner contours. It applies Douglas-Peucker-Ramer simplification and</span>
<span class="sd">        B-spline interpolation to the contours.</span>

<span class="sd">        Args:</span>
<span class="sd">            mask (ndarray): The input mask for the slice.</span>
<span class="sd">            slice_idx (int): The index of the slice being processed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[ndarray, ndarray]: Arrays of outer and inner B-spline contours.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">DP_SIMPLIFICATION_OUTER</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dp_simplification_outer</span>
        <span class="n">DP_SIMPLIFICATION_INNER</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dp_simplification_inner</span>
        <span class="n">out_cont</span><span class="p">,</span> <span class="n">inn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classify_and_store_contours</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">slice_idx</span><span class="p">)</span>

        <span class="n">out_dp</span> <span class="o">=</span> <span class="n">out_cont</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">out_dp</span> <span class="o">=</span> <span class="p">[</span><span class="n">shpg</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">out_dp</span><span class="p">]</span>
        <span class="n">out_dp</span> <span class="o">=</span> <span class="n">shpg</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">out_dp</span><span class="p">)</span>
        <span class="n">out_dp</span> <span class="o">=</span> <span class="n">out_dp</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">DP_SIMPLIFICATION_OUTER</span><span class="p">,</span> <span class="n">preserve_topology</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">xout</span><span class="p">,</span> <span class="n">yout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_bspline</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out_dp</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">))</span>

        <span class="n">out_bspline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">xout</span><span class="p">,</span> <span class="n">yout</span><span class="p">))</span>
        <span class="n">out_bspline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">(</span>
            <span class="p">(</span><span class="n">out_bspline</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">out_bspline</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">slice_idx</span><span class="p">))</span>
        <span class="p">)</span>

        <span class="n">inn_dp</span> <span class="o">=</span> <span class="n">inn</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">inn_dp</span> <span class="o">=</span> <span class="p">[</span><span class="n">shpg</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">inn_dp</span><span class="p">]</span>
        <span class="n">inn_dp</span> <span class="o">=</span> <span class="n">shpg</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">inn_dp</span><span class="p">)</span>
        <span class="n">inn_dp</span> <span class="o">=</span> <span class="n">inn_dp</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">DP_SIMPLIFICATION_INNER</span><span class="p">,</span> <span class="n">preserve_topology</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">xin</span><span class="p">,</span> <span class="n">yin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_bspline</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">inn_dp</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">))</span>

        <span class="n">inn_bspline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">xin</span><span class="p">,</span> <span class="n">yin</span><span class="p">))</span>
        <span class="n">inn_bspline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">(</span>
            <span class="p">(</span><span class="n">inn_bspline</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">inn_bspline</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">slice_idx</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">out_bspline</span><span class="p">,</span> <span class="n">inn_bspline</span></div>


<div class="viewcode-block" id="OCC_volume.get_line_sets">
<a class="viewcode-back" href="../spline_volume.html#spline_volume.OCC_volume.get_line_sets">[docs]</a>
    <span class="k">def</span> <span class="nf">get_line_sets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">contour</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate vertical line sets from contour slices.</span>

<span class="sd">        This function generates vertical line sets from the given contour slices.</span>
<span class="sd">        It aligns the slices based on the first point and collects corresponding points</span>
<span class="sd">        from each slice to form vertical lines.</span>

<span class="sd">        Args:</span>
<span class="sd">            contour (List[ndarray]): List of contour slices.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[List[ndarray]]: List of vertical line sets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_points</span> <span class="o">=</span> <span class="n">contour</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">line_sets</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Align slices based on the first point</span>
        <span class="n">first_point</span> <span class="o">=</span> <span class="n">contour</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">contour</span><span class="p">)):</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">contour</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">first_point</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">min_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
            <span class="n">contour</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">contour</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">-</span><span class="n">min_idx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">pt_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_points</span><span class="p">):</span>
            <span class="n">vertical_ll</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_slice</span> <span class="ow">in</span> <span class="n">contour</span><span class="p">:</span>
                <span class="c1"># Collecting the pt_idx-th point from each slice</span>
                <span class="n">vertical_ll</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_slice</span><span class="p">[</span><span class="n">pt_idx</span><span class="p">])</span>
            <span class="n">line_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertical_ll</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_plots</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line_set</span> <span class="ow">in</span> <span class="n">line_sets</span><span class="p">:</span>
                <span class="n">line_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">line_set</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">line_set</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">line_set</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Matched vertical lines&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">line_sets</span></div>


<div class="viewcode-block" id="OCC_volume.plot_slices_with_slider">
<a class="viewcode-back" href="../spline_volume.html#spline_volume.OCC_volume.plot_slices_with_slider">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_slices_with_slider</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imnp</span><span class="p">,</span> <span class="n">total_slices</span><span class="p">,</span> <span class="n">results</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to plot slices with a slider to navigate through slices.</span>

<span class="sd">        Args:</span>
<span class="sd">            imnp (numpy.ndarray): 3D numpy array representing the image.</span>
<span class="sd">            total_slices (int): Total number of slices.</span>
<span class="sd">            results (list): List of tuples containing outer and inner contour plots for each slice.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span>

        <span class="n">img_display</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">imnp</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">)</span>
        <span class="n">outer_plot</span><span class="p">,</span> <span class="n">inner_plot</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">(</span><span class="n">outer_contour_plot</span><span class="p">,)</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">outer_plot</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">outer_plot</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Outer Contour&quot;</span>
        <span class="p">)</span>
        <span class="p">(</span><span class="n">inner_contour_plot</span><span class="p">,)</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">inner_plot</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">inner_plot</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Inner Contour&quot;</span>
        <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

        <span class="n">axcolor</span> <span class="o">=</span> <span class="s2">&quot;lightgoldenrodyellow&quot;</span>
        <span class="n">ax_slider</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">([</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.65</span><span class="p">,</span> <span class="mf">0.03</span><span class="p">],</span> <span class="n">facecolor</span><span class="o">=</span><span class="n">axcolor</span><span class="p">)</span>
        <span class="n">slider</span> <span class="o">=</span> <span class="n">Slider</span><span class="p">(</span>
            <span class="n">ax_slider</span><span class="p">,</span> <span class="s2">&quot;Slice&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_slices</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">valinit</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">valstep</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>

        <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="n">slice_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">slider</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            <span class="n">img_display</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">imnp</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">total_slices</span><span class="p">[</span><span class="n">slice_idx</span><span class="p">]])</span>
            <span class="n">outer_plot</span><span class="p">,</span> <span class="n">inner_plot</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">slice_idx</span><span class="p">]</span>
            <span class="n">outer_contour_plot</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">outer_plot</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">outer_plot</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">inner_contour_plot</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">inner_plot</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">inner_plot</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw_idle</span><span class="p">()</span>

        <span class="n">slider</span><span class="o">.</span><span class="n">on_changed</span><span class="p">(</span><span class="n">update</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">get_backend</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;agg&quot;</span><span class="p">:</span>
            <span class="n">matplotlib</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s2">&quot;TkAgg&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="OCC_volume.volume_splines_optimized">
<a class="viewcode-back" href="../spline_volume.html#spline_volume.OCC_volume.volume_splines_optimized">[docs]</a>
    <span class="k">def</span> <span class="nf">volume_splines_optimized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imsitk_pad</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate optimized volume splines for cortical and trabecular regions.</span>

<span class="sd">        This function processes the input padded image to generate optimized splines</span>
<span class="sd">        for the cortical and trabecular regions. It includes steps for processing slices,</span>
<span class="sd">        interpolating vertical lines, and performing sanity checks.</span>

<span class="sd">        Args:</span>
<span class="sd">            imsitk_pad (SimpleITK.Image): The padded input image.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[ndarray, ndarray]: Arrays of cortical external and internal contours.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">imnp</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetArrayFromImage</span><span class="p">(</span><span class="n">imsitk_pad</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spacing</span> <span class="o">=</span> <span class="n">imsitk_pad</span><span class="o">.</span><span class="n">GetSpacing</span><span class="p">()</span>
        <span class="n">imnp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">imnp</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">imnp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">imnp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">imnp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Height:</span><span class="se">\t</span><span class="si">{</span><span class="n">height</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">NUM_SLICES</span> <span class="o">=</span> <span class="n">height</span> <span class="o">//</span> <span class="mi">10</span>  <span class="c1"># TODO: parametrize this value</span>
        <span class="n">total_slices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">NUM_SLICES</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="n">processed_slices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">slice_idx</span> <span class="ow">in</span> <span class="n">total_slices</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing slice </span><span class="si">{</span><span class="n">slice_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_slice</span><span class="p">(</span><span class="n">imnp</span><span class="p">,</span> <span class="n">slice_idx</span><span class="p">)</span>
            <span class="n">processed_slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_plots</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_slices_with_slider</span><span class="p">(</span><span class="n">imnp</span><span class="p">,</span> <span class="n">total_slices</span><span class="p">,</span> <span class="n">processed_slices</span><span class="p">)</span>

        <span class="n">outer_contours</span><span class="p">,</span> <span class="n">inner_contours</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">processed_slices</span><span class="p">)</span>
        <span class="n">out_arr_mm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">outer_contours</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.061</span>
        <span class="n">inn_arr_mm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">inner_contours</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.061</span>

        <span class="n">z_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">out_arr_mm</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">cortical_ext_split</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">out_arr_mm</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">z_unique</span><span class="p">))</span>
        <span class="n">cortical_int_split</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">inn_arr_mm</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">z_unique</span><span class="p">))</span>

        <span class="n">line_sets_ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_line_sets</span><span class="p">(</span><span class="n">cortical_ext_split</span><span class="p">)</span>
        <span class="n">line_sets_int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_line_sets</span><span class="p">(</span><span class="n">cortical_int_split</span><span class="p">)</span>

        <span class="n">cortical_ext_interp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate_vertical_lines_3d</span><span class="p">(</span><span class="n">line_sets_ext</span><span class="p">)</span>
        <span class="n">cortical_int_interp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate_vertical_lines_3d</span><span class="p">(</span><span class="n">line_sets_int</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_plots</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># plot cortical_ext_interp and cortical_int_interp</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                <span class="n">cortical_ext_interp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="n">cortical_ext_interp</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Outer Contour&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                <span class="n">cortical_int_interp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="n">cortical_int_interp</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Inner Contour&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="n">slices_ext</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">cortical_ext_interp</span><span class="p">:</span>
            <span class="n">z_value</span> <span class="o">=</span> <span class="n">point</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">z_value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">slices_ext</span><span class="p">:</span>
                <span class="n">slices_ext</span><span class="p">[</span><span class="n">z_value</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">slices_ext</span><span class="p">[</span><span class="n">z_value</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>

        <span class="n">slices_int</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">cortical_int_interp</span><span class="p">:</span>
            <span class="n">z_value</span> <span class="o">=</span> <span class="n">point</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">z_value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">slices_int</span><span class="p">:</span>
                <span class="n">slices_int</span><span class="p">[</span><span class="n">z_value</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">slices_int</span><span class="p">[</span><span class="n">z_value</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>

        <span class="c1"># I really don&#39;t like this back and forth conversion, but tentative fix for now</span>

        <span class="n">all_coords_int</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">slices_int</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">coord_array</span> <span class="ow">in</span> <span class="n">slices_int</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                <span class="n">all_coords_int</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord_array</span><span class="p">)</span>
        <span class="n">cortical_int_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">all_coords_int</span><span class="p">)</span>

        <span class="n">all_coords_ext</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">slices_ext</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">coord_array</span> <span class="ow">in</span> <span class="n">slices_ext</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                <span class="n">all_coords_ext</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord_array</span><span class="p">)</span>
        <span class="n">cortical_ext_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">all_coords_ext</span><span class="p">)</span>  <span class="c1">#! careful, change of name !</span>

        <span class="n">inn_sanity</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">z_value</span><span class="p">,</span> <span class="n">slice_ext_points</span> <span class="ow">in</span> <span class="n">slices_ext</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">out_offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_outer_offset</span><span class="p">(</span><span class="n">slice_ext_points</span><span class="p">)</span>
            <span class="n">inn_dp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_inner_offset</span><span class="p">(</span><span class="n">out_offset</span><span class="p">,</span> <span class="n">slices_int</span><span class="p">[</span><span class="n">z_value</span><span class="p">])</span>
            <span class="n">inn_dp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">inn_dp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">inn_dp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">z_value</span><span class="p">)))</span>
            <span class="n">inn_sanity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inn_dp</span><span class="p">)</span>
        <span class="n">inn_sanity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">inn_sanity</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cortical_ext_array</span><span class="p">,</span> <span class="n">cortical_int_array</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Simone Poncioni.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>